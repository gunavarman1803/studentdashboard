import { __rest, __spreadArray, __assign } from '../../node_modules/tslib/tslib.es6.js';
import React, { forwardRef, useRef, useState, useMemo, useEffect } from 'react';
import classNames from '../../node_modules/classnames/index.js';
import PropTypes from 'prop-types';
import { CFormControlWrapper } from '../form/CFormControlWrapper.js';
import { CMultiSelectNativeSelect } from './CMultiSelectNativeSelect.js';
import { CMultiSelectOptions } from './CMultiSelectOptions.js';
import { CMultiSelectSelection } from './CMultiSelectSelection.js';
import { useForkedRef } from '../../hooks/useForkedRef.js';
import { usePopper } from '../../hooks/usePopper.js';
import isRTL from '../../utils/isRTL.js';
import { flattenOptionsArray, filterOptionsList, createOption, selectOptions } from './utils.js';

var CMultiSelect = forwardRef(function (_a, ref) {
    var _b;
    var allowCreateOptions = _a.allowCreateOptions, className = _a.className, _c = _a.cleaner, cleaner = _c === void 0 ? true : _c, clearSearchOnSelect = _a.clearSearchOnSelect, disabled = _a.disabled, feedback = _a.feedback, feedbackInvalid = _a.feedbackInvalid, feedbackValid = _a.feedbackValid, loading = _a.loading, _d = _a.multiple, multiple = _d === void 0 ? true : _d, id = _a.id, invalid = _a.invalid, label = _a.label, onChange = _a.onChange, onFilterChange = _a.onFilterChange, onHide = _a.onHide, onShow = _a.onShow, options = _a.options, _e = _a.optionsMaxHeight, optionsMaxHeight = _e === void 0 ? 'auto' : _e, _f = _a.optionsStyle, optionsStyle = _f === void 0 ? 'checkbox' : _f, optionsTemplate = _a.optionsTemplate, optionsGroupsTemplate = _a.optionsGroupsTemplate, _g = _a.placeholder, placeholder = _g === void 0 ? 'Select...' : _g, required = _a.required, _h = _a.search, search = _h === void 0 ? true : _h, _j = _a.searchNoResultsLabel, searchNoResultsLabel = _j === void 0 ? 'No results found' : _j, _k = _a.selectAll, selectAll = _k === void 0 ? true : _k, _l = _a.selectAllLabel, selectAllLabel = _l === void 0 ? 'Select all options' : _l, _m = _a.selectionType, selectionType = _m === void 0 ? 'tags' : _m, _o = _a.selectionTypeCounterText, selectionTypeCounterText = _o === void 0 ? 'item(s) selected' : _o, size = _a.size, text = _a.text, tooltipFeedback = _a.tooltipFeedback, valid = _a.valid, virtualScroller = _a.virtualScroller, _p = _a.visible, visible = _p === void 0 ? false : _p, _q = _a.visibleItems, visibleItems = _q === void 0 ? 10 : _q, rest = __rest(_a, ["allowCreateOptions", "className", "cleaner", "clearSearchOnSelect", "disabled", "feedback", "feedbackInvalid", "feedbackValid", "loading", "multiple", "id", "invalid", "label", "onChange", "onFilterChange", "onHide", "onShow", "options", "optionsMaxHeight", "optionsStyle", "optionsTemplate", "optionsGroupsTemplate", "placeholder", "required", "search", "searchNoResultsLabel", "selectAll", "selectAllLabel", "selectionType", "selectionTypeCounterText", "size", "text", "tooltipFeedback", "valid", "virtualScroller", "visible", "visibleItems"]);
    var multiSelectRef = useRef(null);
    var multiSelectForkedRef = useForkedRef(ref, multiSelectRef);
    var dropdownRef = useRef(null);
    var nativeSelectRef = useRef(null);
    var togglerRef = useRef(null);
    var searchRef = useRef(null);
    var isInitialMount = useRef(true);
    var _r = usePopper(), popper = _r.popper, initPopper = _r.initPopper, destroyPopper = _r.destroyPopper;
    var _s = useState(options), _options = _s[0], setOptions = _s[1];
    var _t = useState(visible), _visible = _t[0], setVisible = _t[1];
    var _u = useState(''), searchValue = _u[0], setSearchValue = _u[1];
    var _v = useState([]), selected = _v[0], setSelected = _v[1];
    var _w = useState([]), userOptions = _w[0], setUserOptions = _w[1];
    var filteredOptions = useMemo(function () {
        return flattenOptionsArray(search === 'external'
            ? __spreadArray(__spreadArray([], _options, true), filterOptionsList(searchValue, userOptions), true) : filterOptionsList(searchValue, __spreadArray(__spreadArray([], _options, true), userOptions, true)), true);
    }, [_options, searchValue, userOptions]);
    var flattenedOptions = useMemo(function () { return flattenOptionsArray(options); }, [JSON.stringify(options)]);
    var userOption = useMemo(function () {
        if (allowCreateOptions &&
            filteredOptions.some(function (option) { return option.label && option.label.toLowerCase() === searchValue.toLowerCase(); })) {
            return false;
        }
        return searchRef.current && createOption(String(searchValue), flattenedOptions);
    }, [filteredOptions, searchValue]);
    var popperConfig = {
        placement: (isRTL(multiSelectRef.current) ? 'bottom-end' : 'bottom-start'),
        modifiers: [
            {
                name: 'preventOverflow',
                options: {
                    boundary: 'clippingParents',
                },
            },
            {
                name: 'offset',
                options: {
                    offset: [0, 2],
                },
            },
        ],
    };
    useEffect(function () {
        setOptions(options);
        var _selected = flattenedOptions.filter(function (option) { return option.selected === true; });
        var deselected = flattenedOptions.filter(function (option) { return option.selected === false; });
        _selected && setSelected(selectOptions(_selected, selected, deselected));
    }, [JSON.stringify(options)]);
    useEffect(function () {
        !isInitialMount.current && onFilterChange && onFilterChange(searchValue);
    }, [searchValue]);
    useEffect(function () {
        if (!isInitialMount.current && nativeSelectRef.current) {
            nativeSelectRef.current.dispatchEvent(new Event('change', { bubbles: true }));
        }
        if (popper) {
            popper.update();
        }
    }, [JSON.stringify(selected)]);
    useEffect(function () {
        if (_visible) {
            onShow && onShow();
            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('keyup', handleKeyUp);
            togglerRef.current &&
                dropdownRef.current &&
                initPopper(togglerRef.current, dropdownRef.current, popperConfig);
            searchRef.current && searchRef.current.focus();
        }
        return function () {
            onHide && onHide();
            window.removeEventListener('mouseup', handleMouseUp);
            window.removeEventListener('keyup', handleKeyUp);
            destroyPopper();
        };
    }, [_visible]);
    useEffect(function () {
        isInitialMount.current = false;
    }, []);
    var handleKeyUp = function (event) {
        if (event.key === 'Escape') {
            setVisible(false);
        }
    };
    var handleMouseUp = function (event) {
        if (multiSelectRef.current && multiSelectRef.current.contains(event.target)) {
            return;
        }
        setVisible(false);
    };
    var handleSearchChange = function (event) {
        var value = event.target.value;
        setSearchValue(value);
    };
    var handleSearchKeyDown = function (event) {
        if (event.key === 'Enter' && searchValue && allowCreateOptions) {
            event.preventDefault();
            if (userOption) {
                setSelected(__spreadArray(__spreadArray([], selected, true), userOption, true));
                setUserOptions(__spreadArray(__spreadArray([], userOptions, true), userOption, true));
            }
            if (!userOption) {
                setSelected(__spreadArray(__spreadArray([], selected, true), [
                    filteredOptions.find(function (option) { return String(option.label).toLowerCase() === searchValue.toLowerCase(); }),
                ], false));
            }
            setSearchValue('');
            if (searchRef.current) {
                searchRef.current.value = '';
            }
            return;
        }
        if (searchValue.length > 0) {
            return;
        }
        if (event.key === 'Backspace' || event.key === 'Delete') {
            var last_1 = selected.filter(function (option) { return !option.disabled; }).pop();
            last_1 && setSelected(selected.filter(function (option) { return option.value !== last_1.value; }));
        }
    };
    var handleOptionOnClick = function (option) {
        if (!multiple) {
            setSelected([option]);
            setVisible(false);
            setSearchValue('');
            if (searchRef.current) {
                searchRef.current.value = '';
            }
            return;
        }
        if (option.custom && !userOptions.some(function (_option) { return _option.value === option.value; })) {
            setUserOptions(__spreadArray(__spreadArray([], userOptions, true), [option], false));
        }
        if (clearSearchOnSelect || option.custom) {
            setSearchValue('');
            if (searchRef.current) {
                searchRef.current.value = '';
                searchRef.current.focus();
            }
        }
        if (selected.some(function (_option) { return _option.value === option.value; })) {
            setSelected(selected.filter(function (_option) { return _option.value !== option.value; }));
        }
        else {
            setSelected(__spreadArray(__spreadArray([], selected, true), [option], false));
        }
    };
    var handleSelectAll = function () {
        setSelected(selectOptions(__spreadArray(__spreadArray([], flattenedOptions.filter(function (option) { return !option.disabled; }), true), userOptions, true), selected));
    };
    var handleDeselectAll = function () {
        setSelected(selected.filter(function (option) { return option.disabled; }));
    };
    return (React.createElement(CFormControlWrapper, { describedby: rest['aria-describedby'], feedback: feedback, feedbackInvalid: feedbackInvalid, feedbackValid: feedbackValid, id: id, invalid: invalid, label: label, text: text, tooltipFeedback: tooltipFeedback, valid: valid },
        React.createElement(CMultiSelectNativeSelect, { id: id, multiple: multiple, options: selected, required: required, value: multiple
                ? selected.map(function (option) { return option.value.toString(); })
                : selected.map(function (option) { return option.value; })[0], onChange: function () { return onChange && onChange(selected); }, ref: nativeSelectRef }),
        React.createElement("div", { className: classNames('form-multi-select', (_b = {},
                _b["form-multi-select-".concat(size)] = size,
                _b.disabled = disabled,
                _b['is-invalid'] = invalid,
                _b['is-valid'] = valid,
                _b.show = _visible,
                _b), className), "aria-expanded": _visible, id: id, ref: multiSelectForkedRef },
            React.createElement("div", { className: "form-multi-select-input-group", onClick: function () { return setVisible(true); }, ref: togglerRef },
                React.createElement(CMultiSelectSelection, { multiple: multiple, onRemove: function (option) { return !disabled && handleOptionOnClick(option); }, placeholder: placeholder, search: search, selected: selected, selectionType: selectionType, selectionTypeCounterText: selectionTypeCounterText }, search && (React.createElement("input", __assign({ type: "text", className: "form-multi-select-search", disabled: disabled, autoComplete: "off", onChange: handleSearchChange, onKeyDown: handleSearchKeyDown }, (selected.length === 0 && { placeholder: placeholder }), (selected.length > 0 &&
                    selectionType === 'counter' && {
                    placeholder: "".concat(selected.length, " ").concat(selectionTypeCounterText),
                }), (selected.length > 0 &&
                    !multiple && { placeholder: selected.map(function (option) { return option.label; })[0] }), (multiple &&
                    selected.length > 0 &&
                    selectionType !== 'counter' && { size: searchValue.length + 2 }), { ref: searchRef })))),
                React.createElement("div", { className: "form-multi-select-buttons" },
                    !disabled && cleaner && selected.length > 0 && (React.createElement("button", { type: "button", className: "form-multi-select-cleaner", onClick: function () { return handleDeselectAll(); } })),
                    React.createElement("button", { type: "button", className: "form-multi-select-indicator", onClick: function (event) {
                            event.preventDefault();
                            event.stopPropagation();
                            setVisible(!_visible);
                        } }))),
            React.createElement("div", { className: "form-multi-select-dropdown", role: "menu", ref: dropdownRef },
                multiple && selectAll && (React.createElement("button", { type: "button", className: "form-multi-select-all", onClick: function () { return handleSelectAll(); } }, selectAllLabel)),
                React.createElement(CMultiSelectOptions, { handleOptionOnClick: function (option) { return !disabled && handleOptionOnClick(option); }, loading: loading, options: filteredOptions.length === 0 && allowCreateOptions
                        ? userOption || []
                        : filteredOptions, optionsMaxHeight: optionsMaxHeight, optionsStyle: optionsStyle, optionsTemplate: optionsTemplate, optionsGroupsTemplate: optionsGroupsTemplate, searchNoResultsLabel: searchNoResultsLabel, selected: selected, virtualScroller: virtualScroller, visibleItems: visibleItems })))));
});
CMultiSelect.propTypes = __assign({ className: PropTypes.string, cleaner: PropTypes.bool, clearSearchOnSelect: PropTypes.bool, disabled: PropTypes.bool, loading: PropTypes.bool, multiple: PropTypes.bool, onChange: PropTypes.func, onFilterChange: PropTypes.func, onHide: PropTypes.func, onShow: PropTypes.func, options: PropTypes.array.isRequired, optionsMaxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]), optionsStyle: PropTypes.oneOf(['checkbox', 'text']), optionsTemplate: PropTypes.func, optionsGroupsTemplate: PropTypes.func, placeholder: PropTypes.string, required: PropTypes.bool, search: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['external'])]), searchNoResultsLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.node]), selectAll: PropTypes.bool, selectAllLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.node]), selectionType: PropTypes.oneOf(['counter', 'tags', 'text']), selectionTypeCounterText: PropTypes.string, size: PropTypes.oneOf(['sm', 'lg']), virtualScroller: PropTypes.bool, visible: PropTypes.bool, visibleItems: PropTypes.number }, CFormControlWrapper.propTypes);
CMultiSelect.displayName = 'CMultiSelect';

export { CMultiSelect };
//# sourceMappingURL=CMultiSelect.js.map
